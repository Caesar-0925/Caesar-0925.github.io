[{"title":"5. 最长回文子串","date":"2020-12-29T09:34:00.000Z","date_formatted":{"ll":"2020年12月29日","L":"2020/12/29","MM-DD":"12-29"},"updated":"2020-12-29T13:55:00.586Z","content":"题目\n给定一个字符串 s，找到 s 中最长的回文子串。你可以假设  s 的最大长度为 1000。\n示例 1：\n输入: “babad”\n输出: “bab”\n注意: “aba” 也是一个有效答案。\n示例 2：\n输入: “cbbd”\n输出: “bb”\n题解\n方法一：动态规划\nJavascript 版本\n5. 最长回文子串longestPalindrome.js1234567891011121314151617181920212223242526272829function longestPalindrome(s) &#123;  const len = s.length  /*     注意：与Dart类似，在Javascript中，Array对象的fill方法会使用同一实例填充    const dp = Array(len).fill(Array(len).fill(false))   */  const dp = Array.from(&#123; length: len &#125;, () =&gt; Array(len).fill(false))  let ans = &#x27;&#x27;  for (let l = 0; l &lt; len; l++) &#123;    for (let i = 0; i + l &lt; len; i++) &#123;      const j = i + l      if (l == 0) &#123;        dp[i][j] = true      &#125; else if (l == 1) &#123;        dp[i][j] = s[i] == s[j]      &#125; else &#123;        dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + 1][j - 1]      &#125;      if (dp[i][j] &amp;&amp; l + 1 &gt; ans.length) &#123;        /*          注意：与大多数编程语言不同，在Javascript中，使用String          对象的substring方法截取出的字符串会包含最后一位        */        ans = s.substr(i, l + 1)      &#125;    &#125;  &#125;  return ans&#125;\nObjective-C 版本\n5. 最长回文子串LongestPalindrome.m12345678910111213141516171819202122232425262728+ (NSString *)longestPalindrome:(NSString *)s &#123;  NSUInteger len = s.length;  NSMutableArray *dp = [NSMutableArray array];  for (int m = 0; m &lt; len; m++) &#123;    NSMutableArray *temp = [NSMutableArray array];    for (int n = 0; n &lt; len; n++) &#123;      [temp addObject:@0];    &#125;    [dp addObject:temp];  &#125;  NSString *ans = @&quot;&quot;;  for (int l = 0; l &lt; len; l++) &#123;    for (int i = 0; i + l &lt; len; i++) &#123;      int j = i + l;      if (l == 0) &#123;        dp[i][j] = @1;      &#125; else if (l == 1) &#123;        dp[i][j] = [s characterAtIndex:i] == [s characterAtIndex:j] ? @1 : @0;      &#125; else &#123;        dp[i][j] = ([s characterAtIndex:i] == [s characterAtIndex:j]) &amp;&amp; [dp[i + 1][j - 1] isEqualTo:@1] ? @1 : @0;      &#125;      if ([dp[i][j] isEqualTo:@1] &amp;&amp; l + 1 &gt; ans.length) &#123;        ans = [s substringWithRange:NSMakeRange(i, l + 1)];      &#125;    &#125;  &#125;  return  ans;&#125;\nSwift 版本\n5. 最长回文子串LongestPalindrome.swift1234567891011121314151617181920212223public func longestPalindrome(_ s: String) -&gt; String &#123;  let len = s.count  var dp = [[Bool]](repeating: [Bool](repeating: false, count: len), count: len)  var ans = &quot;&quot;  for l in 0 ..&lt; len &#123;    for i in 0 ..&lt; len - l &#123;      let j = i + l      if l == 0 &#123;        dp[i][j] = true      &#125; else if l == 1 &#123;        /// 注意：在Swift中，String 数据结构没有便捷的下标访问方法和        /// 字符串截取方法，需要自行实现        dp[i][j] = s[i] == s[j]      &#125; else &#123;        dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + 1][j - 1]      &#125;      if dp[i][j] &amp;&amp; l + 1 &gt; ans.count &#123;        ans = s.substring(i, i + l + 1)      &#125;    &#125;  &#125;  return ans&#125;\nDart 版本\n5. 最长回文子串longest_palindrome.dart12345678910111213141516171819202122232425  String longestPalindrome(String s) &#123;    final len = s.length;     /*       注意：这里勿使用filled静态方法创建List，Dart会使用同一个List实例填充      final dp = List.filled(len, List.filled(len, false));    */    final dp = List.generate(len, (index) =&gt; List.filled(len, false));     var ans = &#x27;&#x27;;     for (var l = 0; l &lt; len; l++) &#123;      for (var i = 0; i &lt; len - l; i++) &#123;        final j = i + l;         if (l == 0) &#123;          dp[i][j] = true;         &#125; else if (l == 1) &#123;          dp[i][j] = s[i] == s[j];         &#125; else &#123;          dp[i][j] = (s[i] == s[j]) &amp;&amp; dp[i + 1][j - 1];         &#125;        if (dp[i][j] &amp;&amp; l + 1 &gt; ans.length) &#123;          ans = s.substring(i, i + l + 1);         &#125;      &#125;    &#125;  return ans; &#125;\n","plink":"https://caesar-0925.github.io/2020/12/29/数据结构与算法/5-最长回文子串/"},{"title":"188. 买卖股票的最佳时机 IV","date":"2020-12-28T09:13:00.000Z","date_formatted":{"ll":"2020年12月28日","L":"2020/12/28","MM-DD":"12-28"},"updated":"2020-12-28T18:17:37.486Z","content":"题目\n给定一个整数数组  prices ，它的第 i 个元素  prices[i] 是一支给定的股票在第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。\n注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1：\n输入：k = 2, prices = [2,4,1]\n输出：2\n解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。\n示例 2：\n输入：k = 2, prices = [3,2,6,5,0,3]\n输出：7\n解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。\n随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。\n提示：\n0 &lt;= k &lt;= 109\n0 &lt;= prices.length &lt;= 1000\n0 &lt;= prices[i] &lt;= 1000\n题解\n","plink":"https://caesar-0925.github.io/2020/12/28/数据结构与算法/188-买卖股票的最佳时机IV/"},{"title":"455. 分发饼干","date":"2020-12-25T11:21:27.000Z","date_formatted":{"ll":"2020年12月25日","L":"2020/12/25","MM-DD":"12-25"},"updated":"2020-12-28T09:15:11.676Z","content":"题目：\n假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n对每个孩子 i，都有一个胃口值  g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n示例  1:\n输入: g = [1,2,3], s = [1,1]\n输出: 1\n解释:\n你有三个孩子和两块小饼干，3 个孩子的胃口值分别是：1,2,3。\n虽然你有两块小饼干，由于他们的尺寸都是 1，你只能让胃口值是 1 的孩子满足。\n所以你应该输出 1。\n示例  2:\n输入: g = [1,2], s = [1,2,3]\n输出: 2\n解释:\n你有两个孩子和三块小饼干，2 个孩子的胃口值分别是 1,2。\n你拥有的饼干数量和尺寸都足以让所有孩子满足。\n所以你应该输出 2.\n提示：\n1 &lt;= g.length &lt;= 3 _ 104\n0 &lt;= s.length &lt;= 3 _ 104\n1 &lt;= g[i], s[j] &lt;= 231 - 1\n题解：\nJavascript 版本\nObjective-C 版本\n455.分发饼干FindContentChildren.m123- (NSInteger)findContentChildren:(NSArray *)g withSizes:(NSArray *)s &#123;    return  0;&#125;\nSwift 版本\n455.分发饼干FindContentChildren.swift123func findContentChildren(_ g: [Int], _ s: [Int]) -&gt; Int &#123;    return 0&#125;\nDart 版本\n","plink":"https://caesar-0925.github.io/2020/12/25/数据结构与算法/455-分发饼干/"},{"title":"关于在苹果手机上使用input标签选择图片后图片方向失真的问题","date":"2020-12-22T16:30:20.000Z","date_formatted":{"ll":"2020年12月22日","L":"2020/12/22","MM-DD":"12-22"},"updated":"2020-12-25T11:46:12.964Z","content":"之前在做移动调查项目时遇到在苹果手机上使用input标签选择图片后图片方向失真的问题，以下是我的解决思路。\n","plink":"https://caesar-0925.github.io/2020/12/22/Web/关于在苹果手机上使用input标签选择图片后图片方向失真的问题/"},{"title":"关于博主","date":"2020-12-23T11:49:23.000Z","date_formatted":{"ll":"2020年12月23日","L":"2020/12/23","MM-DD":"12-23"},"updated":"2020-12-23T17:02:32.360Z","content":"自我介绍\n本人是一名大前端技术爱好者，2015年开始从事iOS移动应用开发，2017年接触Vue.js框架，2019年独立负责微信小程序开发。期间，本人负责了公司内部的邮件客户端项目和移动开放平台项目。\n基本情况\n姓名：张凯\n年龄：28 岁\n学历：本科\n城市：深圳\n职业：iOS工程师、Web工程师\n工作年限：5 年\n工作状态：在职\n掌握技能\n\n熟练使用Objective-C、Swift语言进行iOS移动应用开发\n熟练使用Vue/Vue-Router/Vuex技术栈进行移动端Web开发\n熟练进行微信小程序开发，有音视频、远程双录、人脸识别等方面经验\n了解Flutter技术\n\n职业经历\n2015年6月～2017年3月 深圳联友科技有限公司 iOS工程师\n2017年3月～至今 富德保险控股有限公司 iOS工程师、Web工程师\n项目经验\n教育经历\n2011 年 9 月～ 2015 年 6 月 长沙理工大学 计算机科学与技术专业\n","plink":"https://caesar-0925.github.io/about/"}]