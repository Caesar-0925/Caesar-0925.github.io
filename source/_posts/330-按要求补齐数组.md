---
title: 330. 按要求补齐数组
date: 2020-12-29 15:34:46
categories:
  - 数据结构与算法
tags:
  - 贪心算法
---

## 题目

给定一个已排序的正整数数组 nums，和一个正整数  n 。从  [1, n]  区间内选取任意个数字补充到  nums  中，使得  [1, n]  区间内的任何数字都可以用  nums  中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。

### 示例  1:

输入: nums = [1,3], n = 6
输出: 1
解释:
根据 nums  里现有的组合  [1], [3], [1,3]，可以得出  1, 3, 4。
现在如果我们将  2  添加到  nums 中，  组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
其和可以表示数字  1, 2, 3, 4, 5, 6，能够覆盖  [1, 6]  区间里所有的数。
所以我们最少需要添加一个数字。

### 示例 2:

输入: nums = [1,5,10], n = 20
输出: 2
解释: 我们需要添加  [2, 4]。

### 示例  3:

输入: nums = [1,2,2], n = 5
输出: 0

## 题解

### 方法一: 贪心算法

#### Javascript 版本

{% codeblock 330. 按要求补齐数组 lang:javascript https://github.com/Caesar-0925/Javascript-Algorithms/blob/main/src/algorithms/minPatches.js minPatches.js%}
  function minPatches(nums, n) {
    let patches = 0
    let x = 1
    let index = 0
    const len = nums.length

    while (x <= n) {
      if (index < len && nums[index] <= x) {
        x += nums[index]
        index++
      } else {
        x *= 2
        patches++
      }
    }
    
    return patches
  }
{% endcodeblock %}
 
#### Objective-C 版本

{% codeblock 330. 按要求补齐数组 lang:objc https://github.com/Caesar-0925/ObjectiveC-Algorithms/blob/main/ObjectiveC-Algorithms/algorithms/330.minPatch/MinPatches.m MinPatches.m%}
  - (NSUInteger)minPatches:(NSArray *)nums inRange:(NSUInteger)n {
    NSUInteger patches = 0;
    NSUInteger x = 1;
    NSUInteger index = 0;
    NSUInteger len = nums.count;
    
    while (x <= n) {
      if (index < len && [[nums objectAtIndex:index] intValue] <= x) {
        x += [[nums objectAtIndex:index] intValue];
        index ++;
      } else {
        x *= 2;
        patches ++;
      }
    }
    
    return patches;
  }
{% endcodeblock %}

#### Swift 版本

{% codeblock 330. 按要求补齐数组 lang:swift https://github.com/Caesar-0925/Swift-Algorithms/blob/main/Swift-Algorithms.playground/Sources/MinPatches.swift MinPatches.swift%}
  public func minPatches(_ nums: Array<Int>, _ n: Int) -> Int {
    var patches = 0
    var x = 1
    var index = 0
    let len = nums.count
    
    while x <= n {
      if index < len && nums[index] <= x {
        x += nums[index]
        index += 1
      } else {
        x *= 2
        patches += 1
      }
    }
    
    return patches
  }
{% endcodeblock %}

#### Dart 版本

{% codeblock 330. 按要求补齐数组 lang:javascript https://github.com/Caesar-0925/dart_algorithms/blob/main/bin/algorithms/min_patches.dart min_patches.dart%}
  int minPatches(List<int> nums, int n) {
    var patches = 0;
    var x = 1;
    var index = 0;
    final len = nums.length;

    while (x <= n) {
      if (index < len && nums[index] <= x) {
        x += nums[index];
        index++;
      } else {
        x *= 2;
        patches++;
      }
    }

    return patches;
  }
{% endcodeblock %}