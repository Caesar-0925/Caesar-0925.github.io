---
title: 5. 最长回文子串
date: 2020-12-29 09:34:00
categories:

  + 数据结构与算法

tags:

  + 动态规划

---

## 题目

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设  s 的最大长度为 1000。

### 示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

### 示例 2：

输入: "cbbd"
输出: "bb"

## 题解

### 方法一：动态规划

#### Javascript 版本

{% codeblock 5. 最长回文子串 lang:javascript https://github.com/Caesar-0925/Javascript-Algorithms/blob/main/src/algorithms/longestPalindrome.js longestPalindrome.js %}
  function longestPalindrome(s) {
    const len = s.length
    /* 
      注意：与Dart类似，在Javascript中，Array对象的fill方法会使用同一实例填充
      const dp = Array(len).fill(Array(len).fill(false)) 
    */
    const dp = Array.from({ length: len }, () => Array(len).fill(false))
    let ans = ''
    for (let l = 0; l < len; l++) {
      for (let i = 0; i + l < len; i++) {
        const j = i + l
        if (l == 0) {
          dp[i][j] = true
        } else if (l == 1) {
          dp[i][j] = s[i] == s[j]
        } else {
          dp[i][j] = (s[i] == s[j]) && dp[i + 1][j - 1]
        }
        if (dp[i][j] && l + 1 > ans.length) {
          /*
            注意：与大多数编程语言不同，在Javascript中，使用String
            对象的substring方法截取出的字符串会包含最后一位
          */
          ans = s.substr(i, l + 1)
        }
      }
    }
    return ans
  }
{% endcodeblock %}

#### Objective-C 版本

{% codeblock 5. 最长回文子串 lang:objc https://github.com/Caesar-0925/ObjectiveC-Algorithms/blob/main/ObjectiveC-Algorithms/algorithms/longestPalindrome/LongestPalindrome.m LongestPalindrome.m %}
  + (NSString *)longestPalindrome:(NSString *)s {
    NSUInteger len = s.length;
    NSMutableArray *dp = [NSMutableArray array];
    for (int m = 0; m < len; m++) {
      NSMutableArray *temp = [NSMutableArray array];
      for (int n = 0; n < len; n++) {
        [temp addObject:@0];
      }
      [dp addObject:temp];
    }
    NSString *ans = @"";
    for (int l = 0; l < len; l++) {
      for (int i = 0; i + l < len; i++) {
        int j = i + l;
        if (l == 0) {
          dp[i][j] = @1;
        } else if (l == 1) {
          dp[i][j] = [s characterAtIndex:i] == [s characterAtIndex:j] ? @1 : @0;
        } else {
          dp[i][j] = ([s characterAtIndex:i] == [s characterAtIndex:j]) && [dp[i + 1][j - 1] isEqualTo:@1] ? @1 : @0;
        }
        if ([dp[i][j] isEqualTo:@1] && l + 1 > ans.length) {
          ans = [s substringWithRange:NSMakeRange(i, l + 1)];
        }
      }
    }
    return  ans;
  }
{% endcodeblock %}

#### Swift 版本

{% codeblock 5. 最长回文子串 lang:swift https://github.com/Caesar-0925/Swift-Algorithms/blob/main/Swift-Algorithms.playground/Sources/LongestPalindrome.swift LongestPalindrome.swift %}
  public func longestPalindrome(_ s: String) -> String {
    let len = s.count
    var dp = [[Bool]](repeating: [Bool](repeating: false, count: len), count: len)
    var ans = ""
    for l in 0 ..< len {
      for i in 0 ..< len - l {
        let j = i + l
        if l == 0 {
          dp[i][j] = true
        } else if l == 1 {
          /// 注意：在Swift中，String 数据结构没有便捷的下标访问方法和
          /// 字符串截取方法，需要自行实现
          dp[i][j] = s[i] == s[j]
        } else {
          dp[i][j] = (s[i] == s[j]) && dp[i + 1][j - 1]
        }
        if dp[i][j] && l + 1 > ans.count {
          ans = s.substring(i, i + l + 1)
        }
      }
    }
    return ans
  }
{% endcodeblock %}

#### Dart 版本

{% codeblock 5. 最长回文子串 lang:dart https://github.com/Caesar-0925/dart_algorithms/blob/main/bin/algorithms/longest_palindrome.dart longest_palindrome.dart %}
  String longestPalindrome(String s) {
    final len = s.length; 
    /* 
      注意：这里勿使用filled静态方法创建List，Dart会使用同一个List实例填充
      final dp = List.filled(len, List.filled(len, false));
    */
    final dp = List.generate(len, (index) => List.filled(len, false)); 
    var ans = ''; 
    for (var l = 0; l < len; l++) {
      for (var i = 0; i < len - l; i++) {
        final j = i + l; 
        if (l == 0) {
          dp[i][j] = true; 
        } else if (l == 1) {
          dp[i][j] = s[i] == s[j]; 
        } else {
          dp[i][j] = (s[i] == s[j]) && dp[i + 1][j - 1]; 
        }
        if (dp[i][j] && l + 1 > ans.length) {
          ans = s.substring(i, i + l + 1); 
        }
      }
    }
  return ans; 
}
{% endcodeblock %}
